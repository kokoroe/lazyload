(function(f){var g;if(typeof window!=='undefined'){g=window}else if(typeof self!=='undefined'){g=self}g.lazyload=f()})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
module.exports = lazyload;

var inViewport = require('in-viewport');
var lazyAttrs = ['data-src', 'data-background-src'];

global.lzld = lazyload();

// Provide libs using getAttribute early to get the good src
// and not the fake data-src
replaceGetAttribute('Image');
replaceGetAttribute('IFrame');
replaceGetAttribute('Div');
replaceGetAttribute('A');

function registerLazyAttr(attr) {
  if (indexOf.call(lazyAttrs, attr) === -1) {
    lazyAttrs.push(attr);
  }
}

function lazyload(opts) {
  opts = merge({
    'offset': 333,
    'src': 'data-src',
    'container': false
  }, opts || {});

  if (typeof opts.src === 'string') {
    registerLazyAttr(opts.src);
  }

  var elts = [];

  function show(elt) {
    if (elt.hasAttribute('data-background-src')) {
      var src = findRealBackgroundSrc(elt);

      if (src) {
        elt.style.backgroundImage = 'url(' + src + ')';
      }
    } else {
      var src = findRealSrc(elt);

      if (src) {
        elt.src = src;
      }
    }

    elt.setAttribute('data-lzled', true);
    elts[indexOf.call(elts, elt)] = null;
  }

  function findRealBackgroundSrc(elt) {
    if (typeof opts.src === 'function') {
      return opts.src(elt);
    }

    return elt.getAttribute(opts.src == 'data-src' ? 'data-background-src': opts.src);
  }

  function findRealSrc(elt) {
    if (typeof opts.src === 'function') {
      return opts.src(elt);
    }

    return elt.getAttribute(opts.src);
  }

  function register(elt) {
    // unsubscribe onload
    // needed by IE < 9, otherwise we get another onload when changing the src
    elt.onload = null;
    elt.removeAttribute('onload');

    // https://github.com/vvo/lazyload/issues/62
    elt.onerror = null;
    elt.removeAttribute('onerror');

    if (indexOf.call(elts, elt) === -1) {
      inViewport(elt, opts, show);
    }
  }

  return register;
}

function replaceGetAttribute(elementName) {
  var fullname = 'HTML' + elementName + 'Element';
  if (fullname in global === false) {
    return;
  }

  var original = global[fullname].prototype.getAttribute;
  global[fullname].prototype.getAttribute = function(name) {
    if (name === 'src') {
      var realSrc;
      for (var i = 0, max = lazyAttrs.length; i < max; i++) {
        realSrc = original.call(this, lazyAttrs[i]);
        if (realSrc) {
          break;
        }
      }

      return realSrc || original.call(this, name);
    }

    // our own lazyloader will go through theses lines
    // because we use getAttribute(opts.src)
    return original.call(this, name);
  };
}

function merge(defaults, opts) {
  for (var name in defaults) {
    if (opts[name] === undefined) {
      opts[name] = defaults[name];
    }
  }

  return opts;
}

// http://webreflection.blogspot.fr/2011/06/partial-polyfills.html
function indexOf(value) {
  for (var i = this.length; i-- && this[i] !== value;) {}
  return i;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"in-viewport":2}],2:[function(require,module,exports){
(function (global){
module.exports = inViewport;

var instances = [];
var supportsMutationObserver = typeof global.MutationObserver === 'function';

function inViewport(elt, params, cb) {
  var opts = {
    container: global.document.body,
    offset: 0
  };

  if (params === undefined || typeof params === 'function') {
    cb = params;
    params = {};
  }

  var container = opts.container = params.container || opts.container;
  var offset = opts.offset = params.offset || opts.offset;

  for (var i = 0; i < instances.length; i++) {
    if (instances[i].container === container) {
      return instances[i].isInViewport(elt, offset, cb);
    }
  }

  return instances[
    instances.push(createInViewport(container)) - 1
  ].isInViewport(elt, offset, cb);
}

function addEvent(el, type, fn) {
  if (el.attachEvent) {
    el.attachEvent('on' + type, fn);
  } else {
    el.addEventListener(type, fn, false);
  }
}

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this, args = arguments;
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);

    function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    }
  };
}

// https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708
var contains = global.document.documentElement.compareDocumentPosition ?
  function (a, b) {
    return !!(a.compareDocumentPosition(b) & 16);
  } :
  global.document.documentElement.contains ?
    function (a, b) {
      return a !== b && ( a.contains ? a.contains(b) : false );
    } :
    function (a, b) {
      while (b = b.parentNode) {
        if (b === a) {
          return true;
        }
      }
      return false;
    };

function createInViewport(container) {
  var watches = createWatches();

  var scrollContainer = container === global.document.body ? global : container;
  var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);

  addEvent(scrollContainer, 'scroll', debouncedCheck);

  if (scrollContainer === global) {
    addEvent(global, 'resize', debouncedCheck);
  }

  if (supportsMutationObserver) {
    observeDOM(watches, container, debouncedCheck);
  }

  // failsafe check, every 200ms we check for visible images
  // usecase: a hidden parent containing eleements
  // when the parent becomes visible, we have no event that the children
  // became visible
  setInterval(debouncedCheck, 150);

  function isInViewport(elt, offset, cb) {
    if (!cb) {
      return isVisible(elt, offset);
    }

    var remote = createRemote(elt, offset, cb);
    remote.watch();
    return remote;
  }

  function createRemote(elt, offset, cb) {
    function watch() {
      watches.add(elt, offset, cb);
    }

    function dispose() {
      watches.remove(elt);
    }

    return {
      watch: watch,
      dispose: dispose
    };
  }

  function watchInViewport(elt, offset, cb) {
    if (isVisible(elt, offset)) {
      watches.remove(elt);
      cb(elt);
    }
  }

  function isVisible(elt, offset) {
    if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {
      return false;
    }

    // Check if the element is visible
    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js
    if (!elt.offsetWidth || !elt.offsetHeight) {
      return false;
    }

    var eltRect = elt.getBoundingClientRect();
    var viewport = {};

    if (container === global.document.body) {
      viewport = {
        top: -offset,
        left: -offset,
        right: global.document.documentElement.clientWidth + offset,
        bottom: global.document.documentElement.clientHeight + offset
      };
    } else {
      var containerRect = container.getBoundingClientRect();
      viewport = {
        top: containerRect.top - offset,
        left: containerRect.left - offset,
        right: containerRect.right + offset,
        bottom: containerRect.bottom + offset
      };
    }

    // The element must overlap with the visible part of the viewport
    var visible =
      (
        eltRect.right >= viewport.left &&
        eltRect.left <= viewport.right &&
        eltRect.bottom >= viewport.top &&
        eltRect.top <= viewport.bottom
      );

    return visible;
  }

  return {
    container: container,
    isInViewport: isInViewport
  };
}

function createWatches() {
  var watches = [];

  function add(elt, offset, cb) {
    if (!isWatched(elt)) {
      watches.push([elt, offset, cb]);
    }
  }

  function remove(elt) {
    var pos = indexOf(elt);
    if (pos !== -1) {
      watches.splice(pos, 1);
    }
  }

  function indexOf(elt) {
    for (var i = watches.length - 1; i >= 0; i--) {
      if (watches[i][0] === elt) {
        return i;
      }
    }
    return -1;
  }

  function isWatched(elt) {
    return indexOf(elt) !== -1;
  }

  function checkAll(cb) {
    return function () {
      for (var i = watches.length - 1; i >= 0; i--) {
        cb.apply(this, watches[i]);
      }
    };
  }

  return {
    add: add,
    remove: remove,
    isWatched: isWatched,
    checkAll: checkAll
  };
}

function observeDOM(watches, container, cb) {
  var observer = new MutationObserver(watch);
  var filter = Array.prototype.filter;
  var concat = Array.prototype.concat;

  observer.observe(container, {
    childList: true,
    subtree: true,
    // changes like style/width/height/display will be catched
    attributes: true
  });

  function watch(mutations) {
    // some new DOM nodes where previously watched
    // we should check their positions
    if (mutations.some(knownNodes) === true) {
      setTimeout(cb, 0);
    }
  }

  function knownNodes(mutation) {
    var nodes = concat.call([],
      Array.prototype.slice.call(mutation.addedNodes),
      mutation.target
    );
    return filter.call(nodes, watches.isWatched).length > 0;
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwibGF6eWxvYWQuanMiLCJub2RlX21vZHVsZXMvaW4tdmlld3BvcnQvaW4tdmlld3BvcnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gbGF6eWxvYWQ7XG5cbnZhciBpblZpZXdwb3J0ID0gcmVxdWlyZSgnaW4tdmlld3BvcnQnKTtcbnZhciBsYXp5QXR0cnMgPSBbJ2RhdGEtc3JjJywgJ2RhdGEtYmFja2dyb3VuZC1zcmMnXTtcblxuZ2xvYmFsLmx6bGQgPSBsYXp5bG9hZCgpO1xuXG4vLyBQcm92aWRlIGxpYnMgdXNpbmcgZ2V0QXR0cmlidXRlIGVhcmx5IHRvIGdldCB0aGUgZ29vZCBzcmNcbi8vIGFuZCBub3QgdGhlIGZha2UgZGF0YS1zcmNcbnJlcGxhY2VHZXRBdHRyaWJ1dGUoJ0ltYWdlJyk7XG5yZXBsYWNlR2V0QXR0cmlidXRlKCdJRnJhbWUnKTtcbnJlcGxhY2VHZXRBdHRyaWJ1dGUoJ0RpdicpO1xucmVwbGFjZUdldEF0dHJpYnV0ZSgnQScpO1xuXG5mdW5jdGlvbiByZWdpc3RlckxhenlBdHRyKGF0dHIpIHtcbiAgaWYgKGluZGV4T2YuY2FsbChsYXp5QXR0cnMsIGF0dHIpID09PSAtMSkge1xuICAgIGxhenlBdHRycy5wdXNoKGF0dHIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenlsb2FkKG9wdHMpIHtcbiAgb3B0cyA9IG1lcmdlKHtcbiAgICAnb2Zmc2V0JzogMzMzLFxuICAgICdzcmMnOiAnZGF0YS1zcmMnLFxuICAgICdjb250YWluZXInOiBmYWxzZVxuICB9LCBvcHRzIHx8IHt9KTtcblxuICBpZiAodHlwZW9mIG9wdHMuc3JjID09PSAnc3RyaW5nJykge1xuICAgIHJlZ2lzdGVyTGF6eUF0dHIob3B0cy5zcmMpO1xuICB9XG5cbiAgdmFyIGVsdHMgPSBbXTtcblxuICBmdW5jdGlvbiBzaG93KGVsdCkge1xuICAgIGlmIChlbHQuaGFzQXR0cmlidXRlKCdkYXRhLWJhY2tncm91bmQtc3JjJykpIHtcbiAgICAgIHZhciBzcmMgPSBmaW5kUmVhbEJhY2tncm91bmRTcmMoZWx0KTtcblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBlbHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgc3JjICsgJyknO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3JjID0gZmluZFJlYWxTcmMoZWx0KTtcblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBlbHQuc3JjID0gc3JjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbHpsZWQnLCB0cnVlKTtcbiAgICBlbHRzW2luZGV4T2YuY2FsbChlbHRzLCBlbHQpXSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUmVhbEJhY2tncm91bmRTcmMoZWx0KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNyYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9wdHMuc3JjKGVsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsdC5nZXRBdHRyaWJ1dGUob3B0cy5zcmMgPT0gJ2RhdGEtc3JjJyA/ICdkYXRhLWJhY2tncm91bmQtc3JjJzogb3B0cy5zcmMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFJlYWxTcmMoZWx0KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNyYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9wdHMuc3JjKGVsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsdC5nZXRBdHRyaWJ1dGUob3B0cy5zcmMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIoZWx0KSB7XG4gICAgLy8gdW5zdWJzY3JpYmUgb25sb2FkXG4gICAgLy8gbmVlZGVkIGJ5IElFIDwgOSwgb3RoZXJ3aXNlIHdlIGdldCBhbm90aGVyIG9ubG9hZCB3aGVuIGNoYW5naW5nIHRoZSBzcmNcbiAgICBlbHQub25sb2FkID0gbnVsbDtcbiAgICBlbHQucmVtb3ZlQXR0cmlidXRlKCdvbmxvYWQnKTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dm8vbGF6eWxvYWQvaXNzdWVzLzYyXG4gICAgZWx0Lm9uZXJyb3IgPSBudWxsO1xuICAgIGVsdC5yZW1vdmVBdHRyaWJ1dGUoJ29uZXJyb3InKTtcblxuICAgIGlmIChpbmRleE9mLmNhbGwoZWx0cywgZWx0KSA9PT0gLTEpIHtcbiAgICAgIGluVmlld3BvcnQoZWx0LCBvcHRzLCBzaG93KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVnaXN0ZXI7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VHZXRBdHRyaWJ1dGUoZWxlbWVudE5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gJ0hUTUwnICsgZWxlbWVudE5hbWUgKyAnRWxlbWVudCc7XG4gIGlmIChmdWxsbmFtZSBpbiBnbG9iYWwgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsID0gZ2xvYmFsW2Z1bGxuYW1lXS5wcm90b3R5cGUuZ2V0QXR0cmlidXRlO1xuICBnbG9iYWxbZnVsbG5hbWVdLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdzcmMnKSB7XG4gICAgICB2YXIgcmVhbFNyYztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBsYXp5QXR0cnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgcmVhbFNyYyA9IG9yaWdpbmFsLmNhbGwodGhpcywgbGF6eUF0dHJzW2ldKTtcbiAgICAgICAgaWYgKHJlYWxTcmMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhbFNyYyB8fCBvcmlnaW5hbC5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIH1cblxuICAgIC8vIG91ciBvd24gbGF6eWxvYWRlciB3aWxsIGdvIHRocm91Z2ggdGhlc2VzIGxpbmVzXG4gICAgLy8gYmVjYXVzZSB3ZSB1c2UgZ2V0QXR0cmlidXRlKG9wdHMuc3JjKVxuICAgIHJldHVybiBvcmlnaW5hbC5jYWxsKHRoaXMsIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZShkZWZhdWx0cywgb3B0cykge1xuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKG9wdHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0c1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRzO1xufVxuXG4vLyBodHRwOi8vd2VicmVmbGVjdGlvbi5ibG9nc3BvdC5mci8yMDExLzA2L3BhcnRpYWwtcG9seWZpbGxzLmh0bWxcbmZ1bmN0aW9uIGluZGV4T2YodmFsdWUpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoOyBpLS0gJiYgdGhpc1tpXSAhPT0gdmFsdWU7KSB7fVxuICByZXR1cm4gaTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW5WaWV3cG9ydDtcblxudmFyIGluc3RhbmNlcyA9IFtdO1xudmFyIHN1cHBvcnRzTXV0YXRpb25PYnNlcnZlciA9IHR5cGVvZiBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gaW5WaWV3cG9ydChlbHQsIHBhcmFtcywgY2IpIHtcbiAgdmFyIG9wdHMgPSB7XG4gICAgY29udGFpbmVyOiBnbG9iYWwuZG9jdW1lbnQuYm9keSxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcblxuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyID0gcGFyYW1zLmNvbnRhaW5lciB8fCBvcHRzLmNvbnRhaW5lcjtcbiAgdmFyIG9mZnNldCA9IG9wdHMub2Zmc2V0ID0gcGFyYW1zLm9mZnNldCB8fCBvcHRzLm9mZnNldDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnN0YW5jZXNbaV0uY29udGFpbmVyID09PSBjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZXNbaV0uaXNJblZpZXdwb3J0KGVsdCwgb2Zmc2V0LCBjYik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlc1tcbiAgICBpbnN0YW5jZXMucHVzaChjcmVhdGVJblZpZXdwb3J0KGNvbnRhaW5lcikpIC0gMVxuICBdLmlzSW5WaWV3cG9ydChlbHQsIG9mZnNldCwgY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudChlbCwgdHlwZSwgZm4pIHtcbiAgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvYmxvYi8zMTM2ZjQ4YjkwZTNlZGM4NGNiYWFhNmY2Zjc3MzRlZjAzNzc1YTA3L3NpenpsZS5qcyNMNzA4XG52YXIgY29udGFpbnMgPSBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID9cbiAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDE2KTtcbiAgfSA6XG4gIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgP1xuICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAhPT0gYiAmJiAoIGEuY29udGFpbnMgPyBhLmNvbnRhaW5zKGIpIDogZmFsc2UgKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgd2hpbGUgKGIgPSBiLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGIgPT09IGEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUluVmlld3BvcnQoY29udGFpbmVyKSB7XG4gIHZhciB3YXRjaGVzID0gY3JlYXRlV2F0Y2hlcygpO1xuXG4gIHZhciBzY3JvbGxDb250YWluZXIgPSBjb250YWluZXIgPT09IGdsb2JhbC5kb2N1bWVudC5ib2R5ID8gZ2xvYmFsIDogY29udGFpbmVyO1xuICB2YXIgZGVib3VuY2VkQ2hlY2sgPSBkZWJvdW5jZSh3YXRjaGVzLmNoZWNrQWxsKHdhdGNoSW5WaWV3cG9ydCksIDE1KTtcblxuICBhZGRFdmVudChzY3JvbGxDb250YWluZXIsICdzY3JvbGwnLCBkZWJvdW5jZWRDaGVjayk7XG5cbiAgaWYgKHNjcm9sbENvbnRhaW5lciA9PT0gZ2xvYmFsKSB7XG4gICAgYWRkRXZlbnQoZ2xvYmFsLCAncmVzaXplJywgZGVib3VuY2VkQ2hlY2spO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzTXV0YXRpb25PYnNlcnZlcikge1xuICAgIG9ic2VydmVET00od2F0Y2hlcywgY29udGFpbmVyLCBkZWJvdW5jZWRDaGVjayk7XG4gIH1cblxuICAvLyBmYWlsc2FmZSBjaGVjaywgZXZlcnkgMjAwbXMgd2UgY2hlY2sgZm9yIHZpc2libGUgaW1hZ2VzXG4gIC8vIHVzZWNhc2U6IGEgaGlkZGVuIHBhcmVudCBjb250YWluaW5nIGVsZWVtZW50c1xuICAvLyB3aGVuIHRoZSBwYXJlbnQgYmVjb21lcyB2aXNpYmxlLCB3ZSBoYXZlIG5vIGV2ZW50IHRoYXQgdGhlIGNoaWxkcmVuXG4gIC8vIGJlY2FtZSB2aXNpYmxlXG4gIHNldEludGVydmFsKGRlYm91bmNlZENoZWNrLCAxNTApO1xuXG4gIGZ1bmN0aW9uIGlzSW5WaWV3cG9ydChlbHQsIG9mZnNldCwgY2IpIHtcbiAgICBpZiAoIWNiKSB7XG4gICAgICByZXR1cm4gaXNWaXNpYmxlKGVsdCwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3RlID0gY3JlYXRlUmVtb3RlKGVsdCwgb2Zmc2V0LCBjYik7XG4gICAgcmVtb3RlLndhdGNoKCk7XG4gICAgcmV0dXJuIHJlbW90ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZShlbHQsIG9mZnNldCwgY2IpIHtcbiAgICBmdW5jdGlvbiB3YXRjaCgpIHtcbiAgICAgIHdhdGNoZXMuYWRkKGVsdCwgb2Zmc2V0LCBjYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHdhdGNoZXMucmVtb3ZlKGVsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdhdGNoOiB3YXRjaCxcbiAgICAgIGRpc3Bvc2U6IGRpc3Bvc2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd2F0Y2hJblZpZXdwb3J0KGVsdCwgb2Zmc2V0LCBjYikge1xuICAgIGlmIChpc1Zpc2libGUoZWx0LCBvZmZzZXQpKSB7XG4gICAgICB3YXRjaGVzLnJlbW92ZShlbHQpO1xuICAgICAgY2IoZWx0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Zpc2libGUoZWx0LCBvZmZzZXQpIHtcbiAgICBpZiAoIWNvbnRhaW5zKGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGVsdCkgfHwgIWNvbnRhaW5zKGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi83NDBlMTkwMjIzZDE5YTExNGQ1MzczNzU4MTI3Mjg1ZDE0ZDZiNzFlL3NyYy9jc3MvaGlkZGVuVmlzaWJsZVNlbGVjdG9ycy5qc1xuICAgIGlmICghZWx0Lm9mZnNldFdpZHRoIHx8ICFlbHQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsdFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHZpZXdwb3J0ID0ge307XG5cbiAgICBpZiAoY29udGFpbmVyID09PSBnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgICAgdmlld3BvcnQgPSB7XG4gICAgICAgIHRvcDogLW9mZnNldCxcbiAgICAgICAgbGVmdDogLW9mZnNldCxcbiAgICAgICAgcmlnaHQ6IGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyBvZmZzZXQsXG4gICAgICAgIGJvdHRvbTogZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmlld3BvcnQgPSB7XG4gICAgICAgIHRvcDogY29udGFpbmVyUmVjdC50b3AgLSBvZmZzZXQsXG4gICAgICAgIGxlZnQ6IGNvbnRhaW5lclJlY3QubGVmdCAtIG9mZnNldCxcbiAgICAgICAgcmlnaHQ6IGNvbnRhaW5lclJlY3QucmlnaHQgKyBvZmZzZXQsXG4gICAgICAgIGJvdHRvbTogY29udGFpbmVyUmVjdC5ib3R0b20gKyBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVGhlIGVsZW1lbnQgbXVzdCBvdmVybGFwIHdpdGggdGhlIHZpc2libGUgcGFydCBvZiB0aGUgdmlld3BvcnRcbiAgICB2YXIgdmlzaWJsZSA9XG4gICAgICAoXG4gICAgICAgIGVsdFJlY3QucmlnaHQgPj0gdmlld3BvcnQubGVmdCAmJlxuICAgICAgICBlbHRSZWN0LmxlZnQgPD0gdmlld3BvcnQucmlnaHQgJiZcbiAgICAgICAgZWx0UmVjdC5ib3R0b20gPj0gdmlld3BvcnQudG9wICYmXG4gICAgICAgIGVsdFJlY3QudG9wIDw9IHZpZXdwb3J0LmJvdHRvbVxuICAgICAgKTtcblxuICAgIHJldHVybiB2aXNpYmxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBpc0luVmlld3BvcnQ6IGlzSW5WaWV3cG9ydFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVzKCkge1xuICB2YXIgd2F0Y2hlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFkZChlbHQsIG9mZnNldCwgY2IpIHtcbiAgICBpZiAoIWlzV2F0Y2hlZChlbHQpKSB7XG4gICAgICB3YXRjaGVzLnB1c2goW2VsdCwgb2Zmc2V0LCBjYl0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShlbHQpIHtcbiAgICB2YXIgcG9zID0gaW5kZXhPZihlbHQpO1xuICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICB3YXRjaGVzLnNwbGljZShwb3MsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4T2YoZWx0KSB7XG4gICAgZm9yICh2YXIgaSA9IHdhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh3YXRjaGVzW2ldWzBdID09PSBlbHQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzV2F0Y2hlZChlbHQpIHtcbiAgICByZXR1cm4gaW5kZXhPZihlbHQpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQWxsKGNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSB3YXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNiLmFwcGx5KHRoaXMsIHdhdGNoZXNbaV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkZDogYWRkLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGlzV2F0Y2hlZDogaXNXYXRjaGVkLFxuICAgIGNoZWNrQWxsOiBjaGVja0FsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlRE9NKHdhdGNoZXMsIGNvbnRhaW5lciwgY2IpIHtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIod2F0Y2gpO1xuICB2YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcbiAgdmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICAvLyBjaGFuZ2VzIGxpa2Ugc3R5bGUvd2lkdGgvaGVpZ2h0L2Rpc3BsYXkgd2lsbCBiZSBjYXRjaGVkXG4gICAgYXR0cmlidXRlczogdHJ1ZVxuICB9KTtcblxuICBmdW5jdGlvbiB3YXRjaChtdXRhdGlvbnMpIHtcbiAgICAvLyBzb21lIG5ldyBET00gbm9kZXMgd2hlcmUgcHJldmlvdXNseSB3YXRjaGVkXG4gICAgLy8gd2Ugc2hvdWxkIGNoZWNrIHRoZWlyIHBvc2l0aW9uc1xuICAgIGlmIChtdXRhdGlvbnMuc29tZShrbm93bk5vZGVzKSA9PT0gdHJ1ZSkge1xuICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24ga25vd25Ob2RlcyhtdXRhdGlvbikge1xuICAgIHZhciBub2RlcyA9IGNvbmNhdC5jYWxsKFtdLFxuICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICBtdXRhdGlvbi50YXJnZXRcbiAgICApO1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbChub2Rlcywgd2F0Y2hlcy5pc1dhdGNoZWQpLmxlbmd0aCA+IDA7XG4gIH1cbn1cbiJdfQ==
